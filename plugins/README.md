Plug-ins
========

`gulp-component-assembler` supports plug-ins to allow anyone to update the output generated by the `assemble` process.

To view the list of available plug-ins go to the [PLUGINLIST.md file](PLUGINLIST.MD).

There are three different locations where plugins can be processed: `PRE`, `INLINE` and `POST`. When you add your plug-in with `gulp-component-assembler` you indicate when you want the plug-in to be processed. The time of processing indicates where, in the assembles output file the result string of the plug-in will be placed.

| Plug-in Type | Description |
| ----------- | ----------- |
| `PRE` | PRE plug-ins are processed *before* each of the IIFEs of the component are processed. |
| `POST` | POST plug-ins are processed *after* each of the IIFEs of the component are processed. |
| `INLINE_PRE` | INLINE_PRE plug-ins are processed within each of the IIFEs of the component before any code, language string and templates of that component are processed. |
| `INLINE_POST` | INLINE_POST plug-ins are processed within each of the IIFEs of the component after all of the other code, language string and templates of that component are processed. |
| `FILE_PRE` | FILE_PRE plug-ins are processed just before each file of the component are processed. |
| `FILE_POST` | FILE_POST plug-ins are processed just after each file of the component are processed. |

When you create add your plug-in you indicate when the plug-in should be processed.

An example of a plug-in that runs before each IIFE is created.

```JS
  compasm.addPlugin(compasm.pluginType.PRE, myPlugins.preAssembly);
```

An example of a plug-in that runs before each source file is included.

```JS
  compasm.addPlugin(compasm.pluginType.FILE_PRE, myPlugins.preFile);
```

**TODO: Provide more information here**

# How to write a plug-in

Writing your own plug-in is as simple as writing, and exporting a single function. This function takes in the `params` object, processes whatever it needs to process, and returns a `string`. This `string` is then added to the output of the component in the location indicated when you added the plug-in.
> **Note:** _You MUST return a string. If you don't want to add anything then return an empty string_

A plug-in must return a string that contains JavaScript compliant code. Your string is added to the component output file, which is a JavaScript file. So be cautious with your output.

Here is a simple example of a plug-in:

```js
function pluginProcess(params) {
  return "// This is from my plug-in"; // This will add the comment into the output file
}

module.exports = pluginProcess;
```

Then, to use your plug-in you need to include your plug-in in your project and add the following in your `guplfile.js` file:

```js
var gulp   = require('gulp');
var myPlugin  = require('path to your plug-in');
var compasm = require('gulp-component-assembler');

gulp.task('assemble', function() {
  // Add your plug-in as a PRE-processed plug-in
  compasm.addPlugin(compasm.pluginType.PRE, myPlugin);

  return gulp.src('./assembly.json')
    .pipe(compasm.assemble())
    .pipe(gulp.dest('./dist'));
});
```

**TODO: Provide more information here**



### The `params` object passed into your plug-in function

The `params` object is passed into your plug-in function and includes the following properties:

##### Property: projectPath - *{string}*
>This is the absolute path, at the time of assembly, to the folder that contains your assembly.json file.

##### Property: hasTranslations - *{boolean}*
>`hasTranslations` is `true` if there are any valid languages files being processed by this component.

##### Property: options - *{object}*
>The `options` object passed into the `assemble` function in your file `gulpfile.js`.

##### Property: assembly - *{object}*
>The JSON assembly object that is being processed at this time. This is the object that contains the properties `files`, `templates`, `subs`, etc.

##### Property: assemblyFileName - *{string}*
>This is the name of the assembly that is being built minus the `.js` extension. Normally this is the name of the folder that contains the `assembly.json` file.

#### Your own properties in the `assembly.json` file
You can add your own properties into the `assembly.json` file but *please*, in order to reduce the likelihood of name collisions, use name-spacing on all your variable. To do this, preface your variable names with a name that defines your plug-in.

*For example:* If your plug-in is called "banjo" then all of your properties should start with "banjo_" as in the example below:

```js
{
  "files": [ "**/*.js" ],
  "banjo_classes": ["outer", "inner"],
  "banjo_title": "Lost and Found"
}
```

You access the above properties in your plug-in by reading the variables `params.assembly.banjo_classes` and `params.assembly.banjo_title`.

> **Note:** _If you are not planning to use 3rd party plug-ins and don't plan to make your plug-ins available to others then name-spacing is not as important. **But be aware of the name collision risks of not name-spacing.**_

**TODO: Provide more information here**

### Error Handling

When your plug-in encounters an error condition your code has two options:

1 Ignore the error and **return an empty string** which will add nothing to the output

```js
function pluginProcess(params) {
  var error = false;

  // Your logic here

  if (error) {
    return ""; // Return an empty string
  }

  return "// Real string to add to output";
}

module.exports = pluginProcess;
```

2 The error is catastrophic so you should **throw an exception** which will terminate your gulp process. You must throw an instance of the `PluginError` object.

```js
var PluginError = require('gulp-util').PluginError;

function pluginProcess(params) {
  if (!params.assembly.files || params.assembly.files.length < 1) {
    throw new PluginError("my plugin", "You must supply a list of files");
  }

  return "// Real string to add to output";
}

module.exports = pluginProcess;
```
